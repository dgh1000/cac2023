module Util.DataReorg.CmpSpecs where

import qualified Data.Map as M
import qualified Data.List as L
import Text.Printf
import Data.Maybe
import Data.Map(Map)
import Text.Parsec
import Text.Parsec.ByteString.Lazy
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import Data.Text.Lazy(Text)
import qualified Data.ByteString.Lazy as BL
import Data.ByteString.Lazy(ByteString)
import Data.Monoid
import Util.Exception
import Util.Map
import Debug.Trace

{-
comparing two sets of files S (source) and D (destination)

  types of results

    file in S that matches exactly one filename and mod time in D: 

      don't report these

      even if the file in S has a partial match to other files in D, it still
      won't be reported.

    file in S that matches no filename in D

      report these, list full path in S

    file in S with exact match to more than one file in D

      report full path in S and each one in D

    file in S that matches filename but not modification time in D of one or
    more files

      report full path in S, each one in D

  exclusion techniques

    list full path in S to skip matching

    in S: 

      exclude certain extensions, certain directories or trees, or combination

  files in D that aren't in S

    list full path of everything in D. just for edification, probably most of
    these represent new files that don't need to be changed.

output

  match0.txt

  exactGT1.txt

  fnameOnly.txt
  
  destOnly.txt
  
-}

----------------------------------------------------------------------
----------------------------------------------------------------------
--                entry point #1


cmpSpecs :: Config -> [String] -> IO ()
cmpSpecs (Config sources exc_match0 exc_exactGT1 exc_fnameOnly) dests = do
  -- 'sources' and 'dests' are lists of text spec dump filenames. A spec dump
  -- file is a text file generated by listFiles containing specs of all files
  -- within a certain tree.
  srcSpecs <- mapM readSpecFile sources
  let srcSpecs1 = foldl1 (M.unionWith (++)) srcSpecs
  dstSpecs <- mapM readSpecFile dests
  let dstSpecs1 = foldl1 (M.unionWith (++)) dstSpecs
      (match1,match0,exactGT1,fnameOnly) = cmpAll srcSpecs1 dstSpecs1
  report False "rMatch1.txt"    match1    [ExcAny]
  report True  "rMatch0.txt"    match0    exc_match0
  report True  "rExactGT1.txt"  exactGT1  exc_exactGT1
  report True  "rFnameOnly.txt" fnameOnly exc_fnameOnly
  
{-
      match1File    = results2file match1
      match0File    = results2file match0
      exactGT1File  = results2file exactGT1
      fnameOnlyFile = results2file fnameOnly
      -- destOnlyFile  = results2file destOnly
  BL.writeFile "match1.txt"    match1File
  BL.writeFile "match0.txt"    match0File
  BL.writeFile "exactGT1.txt"  exactGT1File
  BL.writeFile "fnameOnly.txt" fnameOnlyFile
  -- BL.writeFile "destOnly.txt"  destOnlyFile
  putStrLn $ printf "\n%-20s Number of occurences\n" "Type"
  putStrLn $ printf "%-20s %d"   "match1"    (length match1)
  putStrLn $ printf "%-20s %d"   "match0"    (length match0)
  putStrLn $ printf "%-20s %d"   "exactGT1"  (length exactGT1)
  putStrLn $ printf "%-20s %d"   "fnameOnly" (length fnameOnly)
  -- putStrLn $ printf "%-20s %d\n" "destOnly"  (length destOnly)
-}
  


----------------------------------------------------------------------
----------------------------------------------------------------------


data Config = Config
  { cSources   :: [String]
  , cMatch0    :: [Exc]
  , cExactGT1  :: [Exc]
  , cFnameOnly :: [Exc]
  }


data Result = Result FileData [FileData] -- <src file> <dest files>


data Exc = ExcFilename String
         | ExcFilenameContains String
         | ExcAny
         | ExcDirContains String
         | ExcDestDirContains String


data FileData = FileData 
  { fdFileName :: Text 
  , fdDir      :: Text 
  , fdModTime  :: Text
  }


----------------------------------------------------------------------
----------------------------------------------------------------------

fileDataDirContains :: FileData -> String -> Bool
fileDataDirContains fdIn d = L.isInfixOf 
  (BL.unpack . TL.encodeUtf8 . TL.pack $ d) 
  (BL.unpack . TL.encodeUtf8 . fdDir $ fdIn)

fileDataNameConatins :: FileData -> String -> Bool
fileDataNameConatins fdIn d = L.isInfixOf 
  (BL.unpack . TL.encodeUtf8 . TL.pack $ d) 
  (BL.unpack . TL.encodeUtf8 . fdFileName $ fdIn)


testExc :: Result -> Exc -> Bool
testExc _ ExcAny = True
testExc (Result (FileData fIn _ _) _) (ExcFilename f) =
  TL.encodeUtf8 (TL.pack f) == TL.encodeUtf8 fIn
testExc (Result fdIn _) (ExcDirContains d) = fileDataDirContains fdIn d
testExc (Result _ destFds) (ExcDestDirContains d) = 
  any (\fd -> fileDataDirContains fd d) destFds 
testExc (Result fdIn _) (ExcFilenameContains d) = fileDataNameConatins fdIn d


----------------------------------------------------------------------
----------------------------------------------------------------------
--            make report: take comparison result, apply exceptions,
--            and output data


report :: Bool -> FilePath -> [Result] -> [Exc] -> IO ()
report writeFlag reportFile results excs = do
  let n1 = length results
      matchExc r = any (testExc r) excs
      r2 = filter (not . matchExc) results
      n2 = length r2
  putStrLn $ printf "%-30s%7d%7d" reportFile n1 n2
  if writeFlag then BL.writeFile reportFile (results2file r2)
               else return ()


----------------------------------------------------------------------
----------------------------------------------------------------------
--           do comparision: take a source file and check how and where it
--          occurs in the destination data


cmpAll :: Map Text [FileData] -> Map Text [FileData] -> 
          ([Result],[Result],[Result],[Result])
cmpAll sources dests =
  mconcat . map (cmpOne dests) . concat . M.elems $ sources



cmpDestFile :: Map Text [FileData] -> FileData -> Maybe Result
cmpDestFile srcMap fdIn@(FileData filename dir modTime) =
  case M.lookup filename srcMap of
    Nothing -> Just $ Result fdIn []
    Just _  -> Nothing


-- result : (<match1>, <match0>, <exactGT1>, <fnameOnly>)
cmpOne :: Map Text [FileData] -> FileData -> 
          ([Result],[Result],[Result],[Result])
cmpOne destMap fdIn@(FileData srcFileName srcDir srcModTime) =
  case M.lookup srcFileName destMap of
    Nothing -> ([],[Result fdIn []],[],[])
    Just destsMatchName -> 
      case L.partition ((==srcModTime) . fdModTime) destsMatchName of
        -- Case that there is no "filename && mod time" match. That means
        -- there were one or more "filename only" matches
        ([],xs)  -> ([],[],[],[Result fdIn xs])
        -- Case there is one "filename && mod time" match. It doesn't matter
        -- if there are other "filename only" matches. In this case there is
        -- nothing to return.
        ([x],_) -> ([Result fdIn [x]],[],[],[])
        -- Case there is more than one "filename && mod time" match. It
        -- doesn't matter if there are other "filename only" matches.
        (xs,_) ->  ([],[],[Result fdIn xs],[])



{-

showFdList :: [FileData] -> String
showFdList fds = printf "--------\n%s" (concatMap g fds)
  where
    g x = "   " ++ showFileData x ++ "\n"


showFileData :: FileData -> String
showFileData (FileData fname dir modTime) = 
  printf "%s %s\\%s" modTime dir fname


showFdMap :: Map String [FileData] -> String
showFdMap = concatMap g . M.toAscList
  where
    g :: (String,[FileData]) -> String
    g (name,ds) = printf "%s: %s" name (showFdList ds)

-}

----------------------------------------------------------------------
----------------------------------------------------------------------

results2file :: [Result] -> ByteString
results2file = BL.concat. map g 
  where
    -- puts CR at end
    fd :: FileData -> ByteString
    fd (FileData fname dir modTime) = BL.concat
        [ TL.encodeUtf8 modTime , toByte " "
        , TL.encodeUtf8 dir     , toByte "\\"
        , TL.encodeUtf8 fname   , toByte "\n" ]
    indent :: ByteString -> ByteString
    indent = BL.append (toByte "   ")
    g :: Result -> ByteString
    g (Result src dests) = BL.append x1 x2
      where
        x1 :: ByteString
        x1 = fd src
        x2 :: ByteString
        x2 = BL.concat $ map (indent . fd) dests


toByte = TL.encodeUtf8 . TL.pack


----------------------------------------------------------------------
----------------------------------------------------------------------


-- toByteString = BL.pack . TL.pack

parseSpecFile :: Parser [(Text,FileData)]
parseSpecFile = many space >> many specFileLine


specFileLine :: Parser (Text,FileData)
specFileLine = do
  modTime <- manyTill (noneOf "|") (char '|')
  name    <- manyTill (noneOf "|") (char '|')
  dir     <- manyTill (notFollowedBy specFileLineEnd >> anyChar) 
                      specFileLineEnd
  many space
  return $ ( TL.pack name
           , FileData (TL.pack name) (TL.pack dir) 
                      (TL.pack modTime))
  

specFileLineEnd = char '|' <|> endOfLine


readSpecFile :: FilePath -> IO (Map Text [FileData])
readSpecFile path = do
  buf <- BL.readFile path
  case parse parseSpecFile "" buf of
    Left err -> throwMine $ printf "while reading %s:\n%s" path (show err)
    Right xs -> return $ listToLMap xs


----------------------------------------------------------------------
----------------------------------------------------------------------
